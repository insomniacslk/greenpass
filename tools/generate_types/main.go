// generate_types.go is meant to be executed by `go generate` to create
// `types.go`.
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"

	"github.com/insomniacslk/xjson"
)

// PackageName is the package name to use in the generated output file.
const PackageName = "greenpass"

var (
	flagOutputFile = flag.String("o", "types.go", "Output file")
	flagVersion    = flag.String("V", "1.3.0", "Version of the Digital COVID Certificate to generate types from")
)

// Header is the JSON header for value sets.
type Header struct {
	ValueSetID     string
	ValueSetDate   string
	ValueSetValues map[string]Value
}

// Value is a value-set value.
type Value struct {
	Display string
	Lang    string
	Active  bool
	Version xjson.URL
	System  xjson.URL
}

func getURL(version, filename string) url.URL {
	return url.URL{
		Scheme: "https",
		Host:   "raw.githubusercontent.com",
		Path:   fmt.Sprintf("/ehn-dcc-development/ehn-dcc-schema/release/%s/valuesets/%s", version, filename),
	}
}

func get(version, filename string) (*Header, error) {
	u := getURL(version, filename)
	resp, err := http.Get(u.String())
	if err != nil {
		return nil, fmt.Errorf("HTTP GET failed: %w", err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read HTTP body: %w", err)
	}
	var hdr Header
	if err := json.Unmarshal(body, &hdr); err != nil {
		return nil, fmt.Errorf("failed to decode JSON header for '%s': %w", filename, err)
	}
	return &hdr, nil
}

func generateType(version, typeName, filename string) (string, error) {
	if strings.Title(typeName) != typeName {
		return "", fmt.Errorf("type name must start with capital letter, got '%s'", typeName)
	}
	if len(typeName) < 2 {
		return "", fmt.Errorf("type name must be at least 2 chars long, got '%s'", typeName)
	}
	nameMapVar := strings.ToLower(typeName[0:1]) + typeName[1:] + "Names"
	hdr, err := get(version, filename)
	if err != nil {
		return "", fmt.Errorf("failed to parse header for '%s': %w", typeName, err)
	}

	var nameMap string
	for k, v := range hdr.ValueSetValues {
		nameMap += fmt.Sprintf("\t\"%s\": \"%s\",\n", k, v.Display)
	}
	data := fmt.Sprintf(`type %s string

func (this %s) String() string {
	name, ok := %s[this]
	if !ok {
		return fmt.Sprintf("unknown('%%s')", this)
	}
	return name
}

var %s = map[%s]string {
%s
}
`, typeName, typeName, nameMapVar, nameMapVar, typeName, nameMap)
	return data, nil
}

func writeFile(outputFile, packageName string, chunks ...string) error {
	fd, err := os.Create(*flagOutputFile)
	if err != nil {
		return fmt.Errorf("failed to open '%s': %v", outputFile, err)
	}
	defer func() {
		if err := fd.Close(); err != nil {
			log.Printf("Error: failed to close file descriptor: %v", err)
		}
	}()
	// TODO validate package name
	header := fmt.Sprintf(`// Code generated by generate_types.go; DO NOT EDIT.

package %s

import (
	"fmt"
)

`, packageName)
	if _, err := fd.WriteString(header); err != nil {
		return fmt.Errorf("failed to write package header to file: %w", err)
	}
	for _, chunk := range chunks {
		if _, err := fd.WriteString(chunk); err != nil {
			return fmt.Errorf("failed to write chunk to file: %w", err)
		}
	}
	return nil
}

func main() {
	flag.Parse()
	log.Print("Generating types")
	genMap := map[string]string{
		"DiseaseAgentTargeted": "disease-agent-targeted",
		"Country2Codes":        "country-2-codes",
	}
	var types []string
	for typeName, fileName := range genMap {
		genType, err := generateType(*flagVersion, typeName, fileName)
		if err != nil {
			log.Fatalf("Failed to generate type '%s': %v", typeName, err)
		}
		types = append(types, genType)
	}
	// write everything to file
	if err := writeFile(*flagOutputFile, PackageName, types...); err != nil {
		log.Fatalf("failed to write file: %v", err)
	}
	log.Printf("Written to file '%s'", *flagOutputFile)
}
