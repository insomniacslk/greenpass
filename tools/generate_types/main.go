// generate_types.go is meant to be executed by `go generate` to create
// `types.go`.
package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"

	"github.com/insomniacslk/xjson"
)

// PackageName is the package name to use in the generated output file.
const PackageName = "greenpass"

var (
	flagOutputFile = flag.String("o", "types.go", "Output file")
	flagVersion    = flag.String("V", "1.3.0", "Version of the Digital COVID Certificate to generate types from")
)

// Header is the JSON header for value sets.
type Header struct {
	ValueSetID     string
	ValueSetDate   string
	ValueSetValues map[string]Value
}

// Value is a value-set value.
type Value struct {
	Display string
	Lang    string
	Active  bool
	Version xjson.URL
	System  xjson.URL
}

func getURL(version, filename string) url.URL {
	return url.URL{
		Scheme: "https",
		Host:   "raw.githubusercontent.com",
		Path:   fmt.Sprintf("/ehn-dcc-development/ehn-dcc-schema/release/%s/valuesets/%s", version, filename),
	}
}

func get(version, filename string) (*Header, error) {
	u := getURL(version, filename)
	resp, err := http.Get(u.String())
	if err != nil {
		return nil, fmt.Errorf("HTTP GET failed: %w", err)
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read HTTP body: %w", err)
	}
	var hdr Header
	if err := json.Unmarshal(body, &hdr); err != nil {
		return nil, fmt.Errorf("failed to decode JSON header for '%s': %w", filename, err)
	}
	return &hdr, nil
}

func generateDiseaseAgentTargeted(version string) (string, error) {
	hdr, err := get(version, "disease-agent-targeted.json")
	if err != nil {
		return "", fmt.Errorf("failed to parse header for DiseaseAgentTargeted: %w", err)
	}

	var nameMap string
	for k, v := range hdr.ValueSetValues {
		nameMap += fmt.Sprintf("\t\"%s\": \"%s\",\n", k, v.Display)
	}
	data := fmt.Sprintf(`type DiseaseAgentTargeted string

func (dat DiseaseAgentTargeted) String() string {
	name, ok := diseaseAgentTargetedNames[dat]
	if !ok {
		return fmt.Sprintf("unknown('%%s')", dat)
	}
	return name
}

var diseaseAgentTargetedNames = map[DiseaseAgentTargeted]string {
%s
}
`, nameMap)
	return data, nil
}

func generateCountry2Codes(version string) (string, error) {
	hdr, err := get(version, "country-2-codes.json")
	if err != nil {
		return "", fmt.Errorf("failed to generate data for Country2Codes: %w", err)
	}

	var nameMap string
	for k, v := range hdr.ValueSetValues {
		nameMap += fmt.Sprintf("\t\"%s\": \"%s\",\n", k, v.Display)
	}
	data := fmt.Sprintf(`type Country2Codes string

func (cc Country2Codes) String() string {
	name, ok := country2CodesNames[cc]
	if !ok {
		return fmt.Sprintf("unknown('%%s')", cc)
	}
	return name
}

var country2CodesNames = map[Country2Codes]string {
%s
}
`, nameMap)
	return data, nil
}

func writeFile(outputFile, packageName string, chunks ...string) error {
	fd, err := os.Create(*flagOutputFile)
	if err != nil {
		return fmt.Errorf("failed to open '%s': %v", outputFile, err)
	}
	defer func() {
		if err := fd.Close(); err != nil {
			log.Printf("Error: failed to close file descriptor: %v", err)
		}
	}()
	// TODO validate package name
	header := fmt.Sprintf(`// Code generated by generate_types.go; DO NOT EDIT.

package %s

import (
	"fmt"
)

`, packageName)
	if _, err := fd.WriteString(header); err != nil {
		return fmt.Errorf("failed to write package header to file: %w", err)
	}
	for _, chunk := range chunks {
		if _, err := fd.WriteString(chunk); err != nil {
			return fmt.Errorf("failed to write chunk to file: %w", err)
		}
	}
	return nil
}

func main() {
	flag.Parse()
	log.Print("Generating types")
	// generate from disease-agent-targeted.json
	diseaseAgentTargeted, err := generateDiseaseAgentTargeted(*flagVersion)
	if err != nil {
		log.Fatalf("Failed to generate DiseaseAgentTargeted: %v", err)
	}
	// generate from country-2-codes.json
	country2Codes, err := generateCountry2Codes(*flagVersion)
	if err != nil {
		log.Fatalf("Failed to generate Country2Codes: %v", err)
	}
	// write everything to file
	if err := writeFile(*flagOutputFile, PackageName,
		diseaseAgentTargeted, country2Codes); err != nil {
		log.Fatalf("failed to write file: %v", err)
	}
	log.Printf("Written to file '%s'", *flagOutputFile)
}
